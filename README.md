# Практична робота 8: Системні виклики в UNIX/POSIX
Цей репозиторій містить розв’язки завдань 8.1–8.4 та завдання за варіантом №23 із практичної роботи з системного програмування. Усі програми написані на мові C, протестовані на FreeBSD, мають англійський інтерфейс (назви змінних, повідомлення у виводі) і демонструють роботу з системними викликами, такими як write(), read(), lseek(), fork(), qsort() та керування пам’яттю через malloc(). Кожна програма супроводжується простим поясненням, що вона робить, і як її запустити.

## Мета роботи
Навчитися використовувати системні виклики в UNIX-подібних системах (зокрема FreeBSD), зрозуміти, як працює пам’ять при створенні процесів (fork()), як поводяться файлові операції та як оптимізувати сортування за допомогою qsort(). Завдання допомагають розібратися в керуванні файлами, процесами та пам’яттю.

## Завдання 8.1: Чи може write() повернути менше байтів, ніж запрошено?
### Питання: 
Чи може виклик write(fd, buffer, nbytes) повернути значення, яке відрізняється від nbytes? Якщо так, то чому? Напишіть програму, яка це показує.
Пояснення: Так, write() може повернути менше байтів, ніж ми просили. Це стається, наприклад, коли пишемо в канал (pipe) з обмеженим розміром буфера, коли диск заповнений або якщо використовується неблокуючий режим. Програма створює канал, встановлює неблокуючий режим і намагається записати 100 КБ даних. Оскільки буфер каналу зазвичай менший, write() запише лише传染
### Код програми:
(https://github.com/Masonishche/ASPZ_Pr8/blob/main/task1.c)

### Що робить програма:

Створює канал (pipe).
Намагається записати 100 КБ даних у неблокуючому режимі.
Виводить, скільки байтів записано, показуючи, що це може бути менше, ніж nbytes.

### Очікуваний результат:
![Знімок екрана 2025-06-06 004153](https://github.com/user-attachments/assets/d5410d3b-b883-4057-929c-21bc43980d19)



## Завдання 8.2: Читання з файлу після lseek()
### Питання: 
Є файл із байтами {4, 5, 2, 2, 3, 3, 7, 9, 1, 5}. Виконується lseek(fd, 3, SEEK_SET);, потім read(fd, &buffer, 4);. Що буде в буфері? Напишіть програму, яка це показує.
### Пояснення: 
Виклик lseek(fd, 3, SEEK_SET) переміщує вказівник на 4-й байт (нумерація з 0), тобто байт зі значенням 2. Потім read() зчитує 4 байти: {2, 3, 3, 7}. Програма створює файл із заданими байтами, виконує операції та виводить вміст буфера.
### Код програми:
(https://github.com/Masonishche/ASPZ_Pr8/blob/main/task2.c)

### Що робить програма:

Створює файл data.bin із байтами {4, 5, 2, 2, 3, 3, 7, 9, 1, 5}.
Переміщує вказівник на 4-й байт.
Читає 4 байти в буфер.
Виводить вміст буфера.
Видаляє файл.

### Очікуваний результат:
B![Знімок екрана 2025-06-06 004323](https://github.com/user-attachments/assets/865cedc5-f344-4540-992e-825c3916c05f)



## Завдання 8.3: Дослідження qsort() та найгірші випадки
### Питання: 
Напишіть програму, яка досліджує найгірші вхідні дані для qsort() і автоматизує їх створення. Перевірте правильність сортування.
### Пояснення: 
Найгірші випадки для qsort() (швидке сортування) — це відсортовані, зворотно відсортовані масиви або масиви з однаковими елементами, бо вони викликають невдалі розбиття (O(n²)). Програма створює різні типи масивів, сортує їх, вимірює час і перевіряє коректність.
### Код програми:
(https://github.com/Masonishche/ASPZ_Pr8/blob/main/task3.c)

### Що робить програма:

Створює масиви (10 000 елементів): відсортований, зворотно відсортований, випадковий, із дублікатами.
Сортує їх за допомогою qsort() і вимірює час.
Перевіряє, чи масиви відсортовані правильно.
Виконує тести на різних випадках (невідсортований, однакові елементи, один елемент, порожній масив).

### Очікуваний результат:
![Знімок екрана 2025-06-06 004507](https://github.com/user-attachments/assets/602f7cc6-5303-4915-8fc0-884a4e909b64)



## Завдання 8.4: Робота з fork()
### Питання: 
Завершіть програму з fork() і поясніть, яким може бути результат.
### Пояснення: 
Виклик fork() створює дочірній процес. У батьківському процесі pid — це ID дочірнього процесу (>0), у дочірньому — pid дорівнює 0. Обидва процеси виводять pid, але порядок виводу залежить від планувальника FreeBSD.
### Код програми:
(https://github.com/Masonishche/ASPZ_Pr8/blob/main/task4.c)

### Що робить програма:

Викликає fork().
Виводить значення pid у батьківському та дочірньому процесах.
Використовує sleep(), щоб вивід був чіткішим.

### Очікуваний результат:
![Знімок екрана 2025-06-06 004730](https://github.com/user-attachments/assets/0504a8ae-00a5-4168-8441-a57d1e1a6471)



## Варіант 23: Аналіз пам’яті після fork()
### Питання: 
Створіть програму, яка аналізує пам’ять, виділену через malloc(), після fork() із зміною значень.
### Пояснення: 
Після fork() батьківський і дочірній процеси мають окремі копії пам’яті (copy-on-write). Зміни в одному процесі не впливають на інший. Програма виділяє пам’ять, створює процеси, змінює значення та показує їх незалежність.
### Код програми:
(https://github.com/Masonishche/ASPZ_Pr8/blob/main/task23.c)

### Що робить програма:

Виділяє масив із 100 чисел через malloc().
Заповнює його значеннями (0, 1, 2, ...).
Викликає fork().
Дочірній процес додає 100 до кожного елемента.
Батьківський процес віднімає 50 від кожного елемента.
Виводить значення в обох процесах.
Батько чекає завершення дитини і перевіряє свою пам’ять.

### Очікуваний результат:
![Знімок екрана 2025-06-06 004900](https://github.com/user-attachments/assets/2bb5147e-cf5b-461d-b72f-92705a4221c5)

## Висновок
Практична робота 8 дозволила глибше розібратися в роботі системних викликів UNIX/POSIX на FreeBSD, зокрема write(), read(), lseek(), fork() та qsort(). Завдання 8.1 показало, що write() може записувати менше байтів через обмеження буфера каналу, що важливо для роботи з великими даними. Завдання 8.2 продемонструвало точне керування позицією у файлі за допомогою lseek() та зчитування даних. Завдання 8.3 допомогло дослідити поведінку qsort(), виявивши, що відсортовані чи зворотно відсортовані масиви є найгіршими випадками через неефективне розбиття. Завдання 8.4 розкрило особливості роботи fork(), показавши, як батьківський і дочірній процеси діють незалежно. Варіант 23 підтвердив, що механізм copy-on-write забезпечує ізоляцію пам’яті між процесами після fork(). Усі програми були написані з урахуванням англійського інтерфейсу, протестовані на FreeBSD і містять коректне керування пам’яттю та обробку помилок. Робота поглибила розуміння системного програмування та практичних аспектів роботи з процесами, файлами та пам’яттю.

